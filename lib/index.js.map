{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import type { NodePath } from \"@babel/core\"\nimport type { BinaryExpression, TemplateLiteral, StringLiteral, NumericLiteral } from \"@babel/types\"\nimport { declare } from '@babel/helper-plugin-utils'\n\ndeclare module '@babel/types' {\n    interface StringLiteral {\n        extra: { raw: string }\n    }\n    interface NumericLiteral {\n        extra: { raw: string }\n    }\n}\ntype TSNLiteral = TemplateLiteral | StringLiteral | NumericLiteral\n\n\nexport default declare((api, options) => {\n    const { types: t } = api\n    const isAlphanumericLiteral = (node: any): node is StringLiteral | NumericLiteral => t.isNumericLiteral(node) || t.isStringLiteral(node)\n    const isTSNLiteral = (node: any): node is TSNLiteral => t.isTemplateLiteral(node) || isAlphanumericLiteral(node)\n    const stringRaw = (val: string): string => JSON.stringify(val).slice(1, -1)\n    /**\n     * get raw value for TemplateElement's `value.raw`\n     */\n    const alphanumericRawValue = (node: StringLiteral | NumericLiteral): string => t.isStringLiteral(node) ? stringRaw(node.value) : node.value.toString()\n    /**\n     * check if TemplateLiteral can be replaced with StringLiteral, if can return the equivalent StringLiteral\n     */\n    const checkTemplateNodeToString = (node: TemplateLiteral): TemplateLiteral | StringLiteral => {\n        if (node.expressions.length === 0) {\n            const value = node.quasis.map(q => q.value.cooked ?? '').join('')\n            return t.stringLiteral(value)\n        }\n        return node\n    }\n    const mergeTSNLiteral = (left: TSNLiteral, right: TSNLiteral): TSNLiteral => {\n        if (t.isNumericLiteral(left) && t.isNumericLiteral(right)) {\n            return t.numericLiteral(left.value + right.value)\n        }\n        if (isAlphanumericLiteral(left) && isAlphanumericLiteral(right)) {\n            // don't use raw (alphanumericRawValue) for StringLiteral\n            // cause 'a\\n' must be 'a\\n' not 'a\\\\n'\n            return t.stringLiteral(left.value.toString() + right.value)\n        }\n        if (t.isTemplateLiteral(left) && t.isTemplateLiteral(right)) {\n            const leftLastRaw = left.quasis[left.quasis.length - 1].value.raw\n            const rightFirstRaw = right.quasis[0].value.raw\n            const quasis = [...left.quasis.slice(0, -1), t.templateElement({ raw: leftLastRaw + rightFirstRaw }), ...right.quasis.slice(1)]\n            return checkTemplateNodeToString(t.templateLiteral(quasis, [...left.expressions, ...right.expressions]))\n        }\n        else if (t.isTemplateLiteral(left) && isAlphanumericLiteral(right)) {\n            const leftLastRaw = left.quasis[left.quasis.length - 1].value.raw\n            const rightVal = alphanumericRawValue(right)\n            const quasis = [...left.quasis.slice(0, -1), t.templateElement({ raw: leftLastRaw + rightVal })]\n            return checkTemplateNodeToString(t.templateLiteral(quasis, left.expressions))\n        }\n        else if (isAlphanumericLiteral(left) && t.isTemplateLiteral(right)) {\n            const leftVal = alphanumericRawValue(left)\n            const rightFirstRaw = right.quasis[0].value.raw\n            const quasis = [t.templateElement({ raw: leftVal + rightFirstRaw }), ...right.quasis.slice(1)]\n            return checkTemplateNodeToString(t.templateLiteral(quasis, right.expressions))\n        }\n        else {\n            throw Error('exhausted')\n        }\n    }\n    /**\n     * optimize BinaryExpression between Literals like which `esbuild` can do.\n     * ```js\n     * 1 + 2 => 3\n     * 'bb' + 2 => bb2\n     * 1 * 2 => 1 * 2\n     * 1 + aNum => 1 + aNum\n     * 1 + 2 + aNum => 3 + aNum\n     * `aaa${'bbb'}` + `ccc${foo()}` => `aaabbbccc${foo()}`\n     * foo() + 'aa' + 'bb' + bar() => foo() + 'aabb' + bar()\n     * ```\n     */\n    const mergeAdjacentLiteralsInBinaryExpression = (path: NodePath<BinaryExpression>) => {\n        let left = path.node.left\n        let right = path.node.right\n        if (t.isBinaryExpression(left)) {\n            mergeAdjacentLiteralsInBinaryExpression(path.get('left') as NodePath<BinaryExpression>)\n        }\n        else if (t.isTemplateLiteral(left)) {\n            checkReplaceLiteralTemplate(path.get('left') as NodePath<TemplateLiteral>)\n        }\n        if (t.isBinaryExpression(right)) {\n            mergeAdjacentLiteralsInBinaryExpression(path.get('right') as NodePath<BinaryExpression>)\n        }\n        else if (t.isTemplateLiteral(right)) {\n            checkReplaceLiteralTemplate(path.get('right') as NodePath<TemplateLiteral>)\n        }\n        right = path.node.right\n        if (!isTSNLiteral(right) || path.node.operator !== '+') {\n            return\n        }\n        left = path.node.left\n        if (isTSNLiteral(left)) {\n            path.replaceWith(mergeTSNLiteral(left, right))\n            return\n        }\n        if (t.isBinaryExpression(left)) {\n            const leftLast = left.right\n            if (!isTSNLiteral(leftLast)) {\n                return\n            }\n            const newRight = mergeTSNLiteral(leftLast, right)\n            path.replaceWith(t.binaryExpression('+', left.left, newRight))\n        }\n    }\n    /**\n     * replace literal templates in TemplateLiterals, all literal templates will be replaced with string literals.\n     * ```ts\n     * `aa${'bb'}` => \"aabb\"\n     * `aa${'bb' + 'cc'}` => \"aabbcc\"\n     * `aa${1 + 2 + '3'}` => \"aa33\"\n     * `aa${1 + '2' + 3}` => \"aa123\"\n     * `aa${1 + 2 + foo()}` => `aa${3 + foo()}`\n     *\n     * ```\n     */\n    const checkReplaceLiteralTemplate = (path: NodePath<TemplateLiteral>) => {\n        const expressions = path.node.expressions\n        const quasis = path.node.quasis\n        if (!expressions.length) {\n            path.replaceWith(t.stringLiteral(quasis.map(q => q.value.cooked ?? '').join('')))\n            return\n        }\n        for (let i = 0; i < expressions.length; i++) {\n            const exp = expressions[i]\n            if (t.isTemplateLiteral(exp)) {\n                // recursion\n                checkReplaceLiteralTemplate(path.get('expressions.' + i) as NodePath<TemplateLiteral>)\n            }\n            else if (t.isBinaryExpression(exp)) {\n                mergeAdjacentLiteralsInBinaryExpression(path.get('expressions.' + i) as NodePath<BinaryExpression>)\n            }\n        }\n        const qs: TemplateLiteral['quasis'] = []\n        const es: TemplateLiteral['expressions'] = []\n        let j = 0\n        // traverse expressions to unbrace literal templates and merge adjacent TemplateElements one by one\n        for (let i = 0; i < expressions.length; i++) {\n            const exp = expressions[i]\n            if (!isAlphanumericLiteral(exp)) {\n                es.push(exp)\n                qs.push(quasis[i])\n                continue\n            }\n            j = i + 1\n            const pre = quasis[i]\n            let next = quasis[j]\n            const expRaw = alphanumericRawValue(exp)\n            let raw = pre.value.raw + expRaw + next.value.raw\n            while (j < expressions.length) {\n                const exp1 = expressions[j]\n                if (isAlphanumericLiteral(exp1)) {\n                    next = quasis[j + 1]\n                    const expRaw = alphanumericRawValue(exp1)\n                    raw += expRaw + next.value.raw\n                    j++\n                    continue\n                }\n                break\n            }\n            qs.push(t.templateElement({ raw }))\n            if (j < expressions.length) {\n                es.push(expressions[j])\n            }\n            i = j\n        }\n        // the last expression is not StringLiteral | NumericLiteral\n        if (j < expressions.length) {\n            qs.push(quasis[quasis.length - 1])\n        }\n\n        if (es.length) {\n            path.replaceWith(t.templateLiteral(qs, es))\n            path.skip()\n        }\n        else {\n            path.replaceWith(t.stringLiteral(qs.map(q => q.value.cooked ?? '').join('')))\n        }\n    }\n\n\n    return {\n        name: 'babel-plugin-optimize-template-literals',\n        visitor: {\n            TemplateLiteral(path) {\n                checkReplaceLiteralTemplate(path)\n            },\n            BinaryExpression(path) {\n                if (options.merging) {\n                    mergeAdjacentLiteralsInBinaryExpression(path)\n                }\n            }\n        }\n    }\n})"],
  "mappings": "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",
  "names": ["expRaw"]
}
